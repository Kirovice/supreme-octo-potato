# 补码与无符号整数：绕圈演示与比较

本实验通过 `unsigned char` 和 `signed char` 类型，验证了计算机中整数加法的“绕圈”行为，并分析了补码的表示原理。

---

## 🧪 目录结构

```bash
mod256-wrap/
├── wrap.c           # 无符号整数 wrap-around 验证
├── wrap_signed.c    # 有符号补码 wrap-around 验证
```

---

## 📄 程序 1：wrap.c（unsigned char）

```c
#include <stdio.h>

int main() {
    unsigned char x = 255;  // 8-bit 无符号整数

    printf("x = %u\n", x);      // 输出：255

    x = x + 1;
    printf("x + 1 = %u\n", x);  // 输出：0

    x = x + 1;
    printf("x + 2 = %u\n", x);  // 输出：1

    return 0;
}
```

### ✅ 输出示例：

```
x = 255
x + 1 = 0
x + 2 = 1
```

---

## 📄 程序 2：wrap_signed.c（signed char）

```c
#include <stdio.h>

int main() {
    signed char x = 127;  // signed char 最大值

    printf("x = %d\n", x);       // 输出：127

    x = x + 1;
    printf("x + 1 = %d\n", x);   // 输出：-128

    x = x + 1;
    printf("x + 2 = %d\n", x);   // 输出：-127

    return 0;
}
```

### ✅ 输出示例：

```
x = 127
x + 1 = -128
x + 2 = -127
```

---

## 🔢 补码与无符号整数表示范围对比（8 位）

| 类型             | 范围              | 二进制解释方式                  | 示例：`10000000` 表示    |
|------------------|-------------------|----------------------------------|--------------------------|
| `unsigned char`  | 0 ~ 255           | 所有位直接按正数解释             | 128                      |
| `signed char`    | -128 ~ +127       | 最高位为符号位，使用补码         | -128                     |

---

## 🎯 补码表示法关键点

- 补码系统把正负数统一到一个“模 256”的数学系统中（8 位时）
- `127 + 1 = -128` 是因为绕了一圈
- 负数补码 = 对应正数的按位取反 + 1

---

## ✅ 总结

| 操作                | `unsigned char` | `signed char` |
|---------------------|------------------|----------------|
| 初始值              | 255              | 127            |
| 加 1 后              | 0                | -128           |
| 再加 1              | 1                | -127           |

通过本实验，我们验证了补码运算如何自动“绕圈”，并理解了补码与无符号整数之间的本质差异。
