# 第1章：计算机系统漫游

## 1. 信息就是位 + 上下文

- 一个字符（如 'A'）在 ASCII 中是 65 → 二进制是 01000001
- 文件保存的不是字符，而是字节序列
- 同样的 0 和 1，在不同上下文中有不同含义
- 比特本身没有意义，意义由上下文赋予

## ASCII 表要点

| 字符 | 十进制 | 二进制 |
|------|--------|--------|
| A    | 65     | 01000001 |
| a    | 97     | 01100001 |

- 补零的方式：在左边高位补 0，直到凑满 8 位为止。

- 在 UTF-8 环境下，如果一个文本文件只包含 ASCII 字符（英文、数字、标点），不管你说它是 ASCII 编码还是 UTF-8 编码，输出的内容是一样的。

| 知识点             | 内容                    |
| --------------- | --------------------- |
| 程序文件 = 字节序列     | 每个字符储存为 ASCII 数字对应的字节 |
| 文本 vs 二进制文件     | 是否全部为可读字符决定           |
| 所有数据本质是比特       | 图像、程序、字符串的统一表示        |
| 上下文决定意义         | 相同字节，在不同地方意义可能完全不同    |
| 机器中的数字 ≠ 人的直观数字 | 可能存在误差或非预期行为          |

## C语言的历史

| 项目              | 说明                                             |
| --------------- | ---------------------------------------------- |
| C语言诞生背景         | 为 Unix 系统设计的系统级语言                              |
| K\&R C / ANSI C | 从最初的草稿到国际标准化                                   |
| 语言特征            | 简洁、可移植、高效、系统控制力强                               |
| 和本书关系           | 本书所有 hello 示例代码就是用 ANSI C 写的                   |
| 和AWS的关系          | AWS EC2 上很多底层中间件、Shell 工具、Zabbix 等都是用 C/C++ 写的 |

## infra工程师与C语言

| 类别     | 你必须掌握                                |
| ------ | ------------------------------------ |
| C 结构   | `main`, `#include`, `return`         |
| 数据类型   | `int`, `char*`, `void*`              |
| 内存模型   | 栈/堆/段错误的基本概念                         |
| 字符串    | `char*` + printf/log 用法              |
| 常用函数   | `malloc`, `open`, `read`, `socket` 等 |
| 调试工具术语 | `bt`, `frame`, `core dump`           |
| 源码阅读能力 | 能看懂 `.c` 文件的主逻辑、函数名、参数结构             |

## 2. 程序被其他程序翻译成不同的格式

- 计算机无法直接理解 C 等高级语言，必须通过编译器将其翻译成低级语言（如汇编或机器码）后，计算机才能执行。

C 源代码（hello.c）
↓ 编译器翻译
机器语言（机器能运行的指令）
↓ 加载进内存
由 CPU 执行

## GCC所做的事情

- gcc 是一个“编译驱动器”程序，它会调用一系列工具，把你写的 C 代码一步步翻译成可执行程序。

| 阶段    | 工具（程序名） | shell 命令示例                  | 输入文件            | 输出文件                 | 主要任务与说明                                              |
| ----- | ------- | --------------------------- | --------------- | -------------------- | ---------------------------------------------------- |
| ① 预处理 | `cpp`   | `gcc -E hello.c -o hello.i` | `hello.c`       | `hello.i`（展开后的 C 程序） | 展开 `#include` 头文件、宏定义 `#define`、条件编译等，得到纯净的 C 代码文本   |
| ② 编译  | `cc1`   | `gcc -S hello.i -o hello.s` | `hello.i`       | `hello.s`（汇编语言）      | 把预处理后的 C 源码翻译为汇编语言指令，每一行大致对应汇编的一条命令                  |
| ③ 汇编  | `as`    | `gcc -c hello.s -o hello.o` | `hello.s`       | `hello.o`（目标文件）      | 把汇编语言翻译为机器指令（二进制格式），但还不是完整程序，称为“可重定位目标文件”            |
| ④ 链接  | `ld`    | `gcc hello.o -o hello`      | `hello.o` + 标准库 | `hello`（可执行文件）       | 把目标文件和标准函数库（如 `printf` 来自 libc）合并，生成可以在系统中运行的完整可执行程序 |

- gcc 实际上是一个“编译驱动器”，它调用了一连串的程序，每一步都把代码“翻译得更接近机器”。


