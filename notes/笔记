# 第1章：计算机系统漫游
    ## 1.1 信息就是位 + 上下文

        * 一个字符（如 'A'）在 ASCII 中是 65 → 二进制是 01000001
        * 文件保存的不是字符，而是字节序列
        * 同样的 0 和 1，在不同上下文中有不同含义
        * 比特本身没有意义，意义由上下文赋予

        ### ASCII 表要点

            | 字符 | 十进制 | 二进制      |
            | -- | --- | -------- |
            | A  | 65  | 01000001 |
            | a  | 97  | 01100001 |

            * 补零的方式：在左边高位补 0，直到凑满 8 位为止。
            * 在 UTF-8 环境下，如果一个文本文件只包含 ASCII 字符（英文、数字、标点），不管你说它是 ASCII 编码还是 UTF-8 编码，输出的内容是一样的。

            | 知识点             | 内容                    |
            | --------------- | --------------------- |
            | 程序文件 = 字节序列     | 每个字符储存为 ASCII 数字对应的字节 |
            | 文本 vs 二进制文件     | 是否全部为可读字符决定           |
            | 所有数据本质是比特       | 图像、程序、字符串的统一表示        |
            | 上下文决定意义         | 相同字节，在不同地方意义可能完全不同    |
            | 机器中的数字 ≠ 人的直观数字 | 可能存在误差或非预期行为          |

        ### C语言的历史

            | 项目              | 说明                                             |
            | --------------- | ---------------------------------------------- |
            | C语言诞生背景         | 为 Unix 系统设计的系统级语言                              |
            | K\&R C / ANSI C | 从最初的草稿到国际标准化                                   |
            | 语言特征            | 简洁、可移植、高效、系统控制力强                               |
            | 和本书关系           | 本书所有 hello 示例代码就是用 ANSI C 写的                   |
            | 和AWS的关系         | AWS EC2 上很多底层中间件、Shell 工具、Zabbix 等都是用 C/C++ 写的 |

        ### Infra 工程师与 C 语言

            | 类别     | 你必须掌握                                |
            | ------ | ------------------------------------ |
            | C 结构   | `main`, `#include`, `return`         |
            | 数据类型   | `int`, `char*`, `void*`              |
            | 内存模型   | 栈/堆/段错误的基本概念                         |
            | 字符串    | `char*` + printf/log 用法              |
            | 常用函数   | `malloc`, `open`, `read`, `socket` 等 |
            | 调试工具术语 | `bt`, `frame`, `core dump`           |
            | 源码阅读能力 | 能看懂 `.c` 文件的主逻辑、函数名、参数结构             |

    ## 1.2 程序被其他程序翻译成不同的格式
        ### 计算机无法直接理解 C 等高级语言，必须通过编译器将其翻译成低级语言（如汇编或机器码）后，计算机才能执行。

            ```
            C 源代码（hello.c）
            ↓ 编译器翻译
            机器语言（机器能运行的指令）
            ↓ 加载进内存
            由 CPU 执行
            ```

        ### GCC 所做的事情

            * gcc 是一个“编译驱动器”程序，它会调用一系列工具，把你写的 C 代码一步步翻译成可执行程序。

            | 阶段    | 工具（程序名） | shell 命令示例                  | 输入文件            | 输出文件                 | 主要任务与说明                                              |
            | ----- | ------- | --------------------------- | --------------- | -------------------- | ---------------------------------------------------- |
            | ① 预处理 | `cpp`   | `gcc -E hello.c -o hello.i` | `hello.c`       | `hello.i`（展开后的 C 程序） | 展开 `#include` 头文件、宏定义 `#define`、条件编译等，得到纯净的 C 代码文本   |
            | ② 编译  | `cc1`   | `gcc -S hello.i -o hello.s` | `hello.i`       | `hello.s`（汇编语言）      | 把预处理后的 C 源码翻译为汇编语言指令，每一行大致对应汇编的一条命令                  |
            | ③ 汇编  | `as`    | `gcc -c hello.s -o hello.o` | `hello.s`       | `hello.o`（目标文件）      | 把汇编语言翻译为机器指令（二进制格式），但还不是完整程序，称为“可重定位目标文件”            |
            | ④ 链接  | `ld`    | `gcc hello.o -o hello`      | `hello.o` + 标准库 | `hello`（可执行文件）       | 把目标文件和标准函数库（如 `printf` 来自 libc）合并，生成可以在系统中运行的完整可执行程序 |

            * gcc 实际上是一个“编译驱动器”，它调用了一连串的程序，每一步都把代码“翻译得更接近机器”。

        ### GNU 项目

            * GNU 项目为现代开源系统打下了基础，GCC 是它最成功的工具之一，而我们日常说的 “Linux 系统” 实际上是“GNU 工具链 + Linux 内核”的组合。

    ## 1.3 了解编译系统如何工作是大有益处的

        虽然写 C 程序不一定需要理解编译器原理，但理解其工作方式有三大重要好处：

        ### ✅ 1. 提高程序性能

            * C 的不同写法编译后机器码性能差异巨大。

            * `switch` 语句 vs `if-else`，哪个快？
            * 循环展开（loop unrolling）能否提升速度？
            * 参数传递的代价、临时变量的优化策略？
            * 熟悉编译器的行为，能帮助你写出运行效率更高的程序。

        ### ✅ 2. 理解错误来源

            * 链接错误通常最令人困惑（undefined reference、duplicate symbol...）。
            * 同名静态变量和全局变量会发生冲突吗？
            * 如果理解编译 + 链接机制，你将能快速定位问题来源。

        ### ✅ 3. 发现安全隐患

            * C 语言不会自动保护内存访问，很多安全漏洞来自「数组越界」「格式字符串错误」等。
            * 编译系统不会自动修复这些问题，但如果了解其原理，你能规避它们。

        ### 总结**：

            > 理解编译器和链接器的工作方式，能帮助你写出更高效、安全、可靠的 C 程序，是成为高级程序员的必经之路。

    ## 1.4 处理器读并解释储存在内存中的指令
        ### 可执行文件运行流程

            - `hello.c` 源程序已经通过编译系统编译成了可执行文件 `hello`
            - 想在 Unix/Linux 系统中运行它，需要通过 shell 命令行调用它：

            ```bash
            ./hello

        ### shell是什么

            | 概念      | 说明                                               |
            | ------- | ------------------------------------------------ |
            | shell   | 命令行解释器，负责读取用户输入的命令并执行                            |
            | ./hello | 当前目录中的可执行程序，`./` 表示当前目录                          |
            | 执行机制    | shell 发现命令不是内部命令，会尝试将其当作“可执行文件”并加载到内存，然后由 CPU 执行 |

        ### 系统的流程

            - 你输入命令 ─► shell 解释命令 ─► 找到 hello 文件 ─► 加载进内存 ─► CPU 读指令并执行 ─► 打印输出 ─► 结束返回

        ### 1.4.1 系统的硬件组成
            #### 总线

                | 关键词     | 含义                      |
                | ------- | ----------------------- |
                | 总线      | 连接各个硬件组件的数据通道（像高速公路）    |
                | 字（word） | 系统传输数据的基本单位，常为 4 或 8 字节 |
                | 字长      | 系统架构的重要参数，影响数据处理和寻址能力   |

            #### I/O

                | 关键词    | 含义                            |
                | ------ | ----------------------------- |
                | I/O 设备 | 计算机和外部世界交互的接口，包括键盘、鼠标、显示器、磁盘等 |
                | 程序的起点  | 程序文件最开始存放在磁盘，运行前要先被读取并加载进内存   |

            #### 控制器与适配器

                - 每个 I/O 设备都通过控制器或适配器连接 I/O 总线

                | 名称     | 类型/定义                                     | 作用                                             | 示例                              |
                |----------|----------------------------------------------|--------------------------------------------------|-----------------------------------|
                | 控制器   | 一种芯片，通常**直接焊接在主板或设备内部**              | 控制 I/O 设备的行为，与 I/O 总线通信                        | 键盘控制器、鼠标控制器、硬盘控制芯片       |
                | 适配器   | 一块**插入主板插槽（如 PCIe）的扩展卡**              | 提供额外功能或连接外部 I/O 设备，桥接 I/O 总线与设备通信        | 显卡（GPU）、声卡、网卡等              |
                | 共通功能 | ——                                             | 都起到“**中介角色**”：连接 I/O 设备 ↔ I/O 总线 ↔ 系统其他部分 | ——                                |

                - 磁盘 ─ 控制器/适配器 ─ I/O 总线 ─ I/O 桥 ─ 系统总线 ─ CPU/内存

            #### 主存
                ###  主存（Main Memory）

                    - 主存，也叫 **内存（Memory）**、**RAM**，是程序运行的临时场所。
                    - 类型为 **DRAM**（动态随机存储器），关机后内容会清空。
                    - 程序运行前，必须先加载到主存中。
                    - 主存可以看作是一个 **按字节编号的大数组**，每个字节都有唯一地址。

                ###  存储系统的三级结构

                    计算机为了在速度和成本之间平衡，采用了三级存储结构：

                    | 层级       | 内容                     | 类型      | 特点                       |
                    |------------|--------------------------|-----------|----------------------------|
                    | ✅ Cache    | 缓存，位于 CPU 内部       | SRAM      | 最快但容量极小（KB~MB），用于保存 CPU 最近的数据 |
                    | ✅ 主存 RAM | 内存，程序运行的地方       | DRAM      | 较快，中等容量（GB），断电清空       |
                    | ✅ 外存     | SSD / 硬盘，永久存储       | SSD / HDD | 最慢但容量大（TB），断电不清空       |

                ###  三者的类比理解

                    | 元素       | 类比                          |
                    |------------|-------------------------------|
                    | Cache      | 你手边的便利贴（最近要记的内容） |
                    | 主存 RAM   | 桌面文件夹（当天处理的资料）      |
                    | 外存（磁盘） | 文件柜（存档、历史资料）          |

                ###  数据的流转顺序

                    ```text
                    程序 hello.c 保存在磁盘中
                    ↓（打开程序）
                    加载进 主存 RAM 中
                    ↓（执行程序）
                    CPU 从主存读取指令和数据
                    ↓（为了更快）
                    经常用的数据保存在 Cache 中

            #### CPU
                ##### 🧠 CPU（中央处理器）概要

                    - **CPU（Central Processing Unit）** 是整个系统的“大脑”，负责解释和执行内存中的指令。
                    - CPU 内部包含一个特殊的寄存器：**程序计数器（PC，Program Counter）**，也叫 **指令指针**。
                    
                    ### 寄存器和缓存cache

                        | 属性        | **寄存器 Register**                    | **缓存 Cache**                     |
                        | --------- | ----------------------------------- | -------------------------------- |
                        | **位置**    | CPU **核心内部**                        | CPU 与 主存之间的**中间层**               |
                        | **用途**    | 存储**当前正在用**的变量/地址/指令等               | 缓存**近期/可能会用**的主存数据               |
                        | **容量**    | 极小（十几个～几十个）                         | 小～中（几 KB～几十 MB）                  |
                        | **速度**    | 极快（最快的存储层次）                         | 次快（比寄存器慢，比主存快）                   |
                        | **管理方式**  | 由编译器 / 程序员 **显式操作**                 | 由**硬件自动管理**（如最近最少使用 LRU）         |
                        | **是否可编程** | 是：程序员可以通过汇编语句直接读写寄存器                | 否：程序员**无法控制**缓存行为（缓存命中/未命中）      |
                        | **示例**    | `eax`, `rbx`, `rsp`, `rip`, `pc`, … | L1 Cache（一级缓存）、L2 Cache、L3 Cache |
                        
                        寄存器是 CPU 立即执行用的高速变量盒子，缓存是帮 CPU 提前准备好数据的聪明仓库。

                    ### 🧾 程序计数器（PC）的作用

                    - PC 始终**指向主存中下一条即将执行的机器语言指令的地址**；
                    - 程序每执行完一条指令，CPU 就会根据执行情况更新 PC；
                    - PC 控制着程序的执行流程（除非遇到跳转、分支、函数调用等控制流改变）。

                ##### ⚙️ CPU 的工作模型

                    - CPU 遵循**指令集架构（ISA）**的规则来解释每条机器指令；
                    - 每条指令都会被翻译成多个微操作（micro-ops）；
                    - 指令的执行过程大致如下：
                    1. 从 PC 指定的地址读取指令；
                    2. 执行指令；
                    3. 更新 PC，使其指向下一条指令。

                    ### 说明补充**：

                        - **PC 是一种寄存器**，是寄存器的一种特例；
                        - **所有机器指令都保存在主存中**，CPU 执行时逐条读取；
                        - 正常情况下，指令是按顺序执行的，除非程序显式地改变流程（如跳转语句、函数调用等）。

                ##### 📘 指令执行模型 vs 指令集架构（ISA）
                    ###### ✅ 简明结论

                        > **指令执行模型是由指令集架构（ISA）决定的。**

                        虽然实际执行可能使用不同的优化技术（如乱序执行、流水线等），但从程序员的角度看，执行模型应符合 ISA 的定义。

                        ---

                    ###### 🧠 概念区分

                        | 概念                     | 说明                                                                 |
                        |--------------------------|----------------------------------------------------------------------|
                        | **指令集架构（ISA）**     | 定义了程序员能看到的“机器语言”：指令种类、格式、寄存器、寻址方式等，是公开标准。           |
                        | **指令执行模型**           | 程序运行表面看起来的语义模型（如一条条顺序执行），由 ISA 决定，影响程序如何理解 CPU 行为。   |
                        | **微架构（Microarchitecture）** | 实际硬件实现，例如是否采用乱序执行、流水线、缓存等优化技术，是 ISA 的具体实现细节。         |

                        ---

                    ###### 🧩 类比解释

                        - **ISA 是交通法规**：红灯停，绿灯行，左转打灯……  
                        - **指令执行模型是运行规则**：每次只能一辆车通过，先北后南……
                        - **微架构是车辆结构**：自行车、电动车、特斯拉内部结构不同，但都遵守交通规则

                        ✅ 顺序一致性（看起来像顺序）
                        ✅ 乱序执行（实际上为了更快）
                        ---

                    ###### ✅ 问题答疑汇总

                        | 问题                           | 回答                                                           |
                        |--------------------------------|----------------------------------------------------------------|
                        | 指令执行模型是否由 ISA 决定？     | ✅ 是的，执行模型是由 ISA 定义的运行行为                            |
                        | 执行模型和实现方式是一一对应吗？  | ❌ 否，执行模型一样，实现可以不同（如乱序 vs 顺序执行）                |
                        | 程序员能看到的是哪个层次？         | 👉 ISA 层，如汇编代码、寄存器、内存地址                                 |
                        | 不同厂商 CPU 可以实现同一个 ISA 吗？| ✅ 可以，例如 Intel 和 AMD 都支持 x86-64                                |

                        ---

                    ###### 总结**：  

                        理解“ISA 决定执行模型”的原则，有助于我们：
                        - 更好地理解编译器行为
                        - 阅读反汇编代码
                        - 进行跨平台编程时理解差异

                ##### CPU工作流程
                    ###### CPU 指令类型四大类：加载 / 存储 / 运算 / 跳转

                        | 操作类型             | 内部流动过程                | 描述（发生了什么）                                          | 类比功能（对应你写 C 程序时的作用）                     |
                        | ---------------- | --------------------- | -------------------------------------------------- | --------------------------------------- |
                        | 🔸 加载（load）      | 主存 → 寄存器              | 从内存中读取一个字（或字节）放入寄存器，**覆盖寄存器原有的内容**                 | 读取变量值                                   |
                        | 🔸 存储（store）     | 寄存器 → 主存              | 把寄存器中保存的值写入内存某个地址，**覆盖该地址原有的内容**                   | 把变量值写回内存、保存运算结果                         |
                        | 🔸 运算（operation） | 寄存器 + 寄存器 → ALU → 寄存器 | 把两个寄存器的内容送入 ALU 做加法/乘法等，**运算结果再存入目标寄存器，覆盖原值**      | 表达式求值，如 `c = a + b`                     |
                        | 🔸 跳转（jump）      | 指令中取地址 → 写入程序计数器（PC）  | 从当前执行的指令中获取跳转地址（如 if 的分支），**更新 PC，决定下一条要执行的指令在哪儿** | 控制流程语句，如 `if`, `while`, `function call` |

                    ###### 寄存器文件

                        - 是 CPU 内部的小型高速存储器，由多个定长的寄存器组成。
                        - 每个寄存器都有一个唯一名称，如 %eax、%rbp 等。
                        - 用来存储运算中间值、临时变量、地址、指令计数等。

                    ###### 算术/逻辑单元ALU

                        - ALU（Arithmetic Logic Unit）是用于执行加减乘除、逻辑运算（与、或、非等）的计算组件。
                        - 从寄存器中读取操作数，运算结果写回寄存器。    
        ### 1.4.2 运行hello程序
            #### 图1.5说明

                键盘 → USB 控制器 → I/O 总线 → I/O 桥 → 系统总线 → CPU（寄存器）→ 主存

                | 图中组件         | 作用说明                                         |
                | ------------ | -------------------------------------------- |
                | **键盘**       | 用户输入命令，比如 `./hello`                          |
                | **USB 控制器**  | 负责读取键盘的按键信息并转换成数字编码（如 ASCII）                 |
                | **I/O 总线**   | 键盘传来的数据经过这里，送往系统内部（可以理解为“外设通道”）              |
                | **I/O 桥**    | I/O 总线与系统总线之间的桥梁，转接数据流                       |
                | **系统总线**     | 负责数据在 CPU、主存、I/O 之间的传输（像高速公路）                |
                | **CPU（寄存器）** | 数据先进入寄存器做临时处理/缓冲（寄存器是 CPU 内部的小型高速存储器）        |
                | **主存储器（主存）** | shell 程序会把用户的输入（如 `./hello`）字符写入这里，准备后续分析和执行 |
            
            #### 图1-6说明

                当你按下回车，shell 知道命令结束了，于是调用系统功能，把 hello 程序从磁盘加载进内存，并包括它要输出的文字 hello, world\n，为后续运行做好准备。

                #### DMA

                    - DMA：Direct Memory Access（直接内存访问）
                    - 不经过 CPU，直接从 I/O 设备向内存传数据 的技术
                    - 拿本例来说，DMA 控制器直接把 hello 程序从磁盘读入主存，而 CPU 不需要参与搬运数据。

                | 步骤 | 执行环节           | 主要动作                                                | 说明                                          |
                | -- | -------------- | --------------------------------------------------- | ------------------------------------------- |
                | 1  | 用户输入           | 用户在 shell 中输入 `./hello`                             | shell 是命令解释器，会尝试将该命令解释为执行当前目录下的可执行程序        |
                | 2  | shell 发起系统调用   | shell 调用 `execve("./hello")`                        | 这是一个系统调用，向内核请求“执行 hello 程序”                 |
                | 3  | 磁盘读取           | 操作系统开始从磁盘中读取 `hello` 文件（程序代码 + 数据）                  | `hello` 是一个 ELF 格式的可执行文件，实际位于 SSD 或 HDD 等外存 |
                | 4  | 内存加载（DMA）      | 操作系统通过 **DMA 控制器** 将 hello 程序加载进主存                  | **DMA（直接内存访问）** 模块直接搬运数据，不需要 CPU 参与         |
                | 5  | 程序计数器（PC）开始执行  | CPU 的 PC（程序计数器）开始读取主存中 hello 程序的第一条指令               | PC 是 CPU 中的寄存器，始终指向即将执行的下一条指令地址             |
                | 6  | 指令执行（如 printf） | CPU 执行主存中 hello 程序的指令，包括 `printf("hello, world\n")` | `printf` 是一个标准库函数，其代码也会被加载到主存中并由 CPU 执行     |
                | 7  | 输出到屏幕          | printf 函数最终通过 I/O 控制器，把字符串输出到终端/显示器                 | 显示的内容为 `hello, world`，程序结束                  |

            #### 图1-7说明

                主存储器 → CPU → I/O 总线 → 图形适配器 → 显示器

                | 组件名称           | 功能说明                                  |
                | -------------- | ------------------------------------- |
                | **主存储器**       | 存放程序的指令、变量和字符串常量（例如 "hello, world\n"） |
                | **CPU 寄存器文件**  | 临时保存数据，比如逐个字符加载到寄存器进行处理或传送            |
                | **ALU**        | 如果要对字符串处理（比如格式化），会参与简单运算              |
                | **I/O 桥和系统总线** | 连接 CPU 与外部设备（例如显卡）的传输通道               |
                | **图形适配器**      | 类似显卡，它负责把数据转成适合显示的信号格式（如 VGA、HDMI）    |
                | **显示器**        | 最终将字符 “hello, world” 呈现给用户            |

            #### 总结

                1. 用户键入命令：./hello
                ↓
                2. shell 读取命令 → 存入内存
                ↓
                3. shell 调用 execve → 请求操作系统加载程序
                ↓
                4. 操作系统通过 DMA 把 hello 可执行文件从磁盘加载到主存
                ↓
                5. CPU 的 PC 寄存器指向 hello 程序的第一条指令，开始执行
                ↓
                6. 执行 printf → 输出字符串
                ↓
                7. 数据从主存 → CPU → 图形适配器 → 屏幕显示 "hello, world"

                输入：键盘敲命令 → shell 读取
                加载：execve 系统调用 → DMA 加载程序
                执行：PC 执行 main → printf 输出
                输出：字符串 → 图形适配器 → 显示器亮起

    ## 1.5 高速缓存至关重要（Cache Matters）
        ### 📌 背景问题：为什么需要缓存？

            - 程序最开始保存在 **磁盘（硬盘/SSD）**
            - 运行时，需要先从磁盘加载到 **主存（RAM）**，然后由 **CPU 从主存读取并执行**
            - 但是磁盘和主存都远比 CPU 慢 → 数据搬运变成瓶颈！

            > 💡 系统设计目标之一：**让处理器尽可能快地完成工作（减少等待）**

        ### 内存墙（Memory Wall）

            | 项目   | 内容                               |
            | ---- | -------------------------------- |
            | 概念   | CPU 性能提升快，内存速度提升慢 → 导致“等内存”的瓶颈问题 |
            | 影响   | CPU 处理速度浪费，程序整体变慢                |
            | 解决方式 | 多级缓存、数据局部性优化、预取、使用更快的内存          |

        ### ⚙️ 存储设备的速度差异（对比）

            | 存储类型     | 访问速度（相对） | 特点说明                                   |
            |------------|----------------|----------------------------------------|
            | 寄存器       | 🚀🚀🚀🚀🚀        | 最快，位于 CPU 内部，仅有几十个字节              |
            | 主存 RAM     | 🚀🚀            | 比寄存器慢，但容量大（GB 级）                  |
            | 磁盘（外存）   | 🐢              | 最慢，访问开销是主存的 10 万倍以上，初始数据保存在此处 |

        ### 💡 解决方案：引入高速缓存（Cache）

            - Cache 是介于 CPU 与主存之间的中间存储层
            - 小容量 + 高速度，缓存最近或即将使用的数据
            - 大大减少主存访问次数，提升整体系统执行效率

        ### 📊 高速缓存的多级结构（图 1-8）

            | 缓存层级 | 所在位置          | 容量范围         | 相对速度          | 技术说明         |
            |--------|-----------------|---------------|-----------------|----------------|
            | L1     | CPU 核心内部       | 数万字节         | ⚡ 最快（寄存器级）     | SRAM（静态 RAM） |
            | L2     | 与核心同芯片、专线连接 | 数十万~几百万字节    | ⚡⚡ 比 L1 慢，但比主存快 | SRAM            |
            | L3     | 有些系统支持，芯片共享 | 数 MB            | ⚡⚡⚡ 最慢的缓存，但仍远快于主存 | SRAM            |

        ### 🧠 原理：程序的**局部性**特性

            - **时间局部性**：刚访问的数据很快还会再用
            - **空间局部性**：访问某地址，也会用到其邻近的数据

            📌 利用这两点，把常用数据预先存进 Cache，大部分操作都命中 → 提高效率！

        ### ✅ 核心总结

            - Cache 是解决 CPU 与主存速度鸿沟的有效手段
            - 通过三级结构（L1 / L2 / L3）层层加速
            - 程序执行效率将因此 **提升数倍至数十倍**

            > 🎯 学习 Cache 的原理，是掌握系统优化与理解现代计算机架构的关键  
            > 📘 第 6 章将详细讨论 DMA、缓存一致性等高级话题

    ## 1.6 存储设备形成层次结构    
        ### 图1-9

            在主存和处理器之间插入一个更小更快的存储设备（如高速缓存）的想法，已经成为现代计算机的通用设计。
            每台计算机的存储系统都被组织成了一个分层结构（Memory Hierarchy），如下图所示：

            更小
            更快
            更贵的存储设备
                ▲
                │
            L0：寄存器（Register）
            L1：L1 高速缓存（SRAM）
            L2：L2 高速缓存（SRAM）
            L3：L3 高速缓存（SRAM）
            L4：主存（DRAM）
            L5：本地二级存储（本地磁盘 SSD/HDD）
            L6：远程二级存储（网络文件系统、Web 服务器等）
                │
                ▼
            更大
            更慢
            更便宜的存储设备

        ### 存储器层级结构对比表

            | 特性         | 层级越高（靠近 CPU）                    | 层级越低（远离 CPU）                      |
            |--------------|------------------------------------------|--------------------------------------------|
            | 📍访问速度    | 非常快（纳秒级）                         | 较慢（微秒～毫秒甚至秒）                   |
            | 📦容量        | 较小（KB～MB）                          | 较大（GB～TB～PB）                         |
            | 💰成本        | 高（如 SRAM）                           | 低（如 DRAM、Flash、HDD、网络）           |
            | 🔁使用频率    | 高频，临近 CPU 的数据和指令                | 低频，较远或冷数据，持久保存用              |
            | 🗂用途        | 缓存下一层存储的数据（起到加速作用）         | 存放长期数据或大容量程序文件，作为主存或磁盘  |

    ## 1.7 操作系统管理硬件

        shell加载运行程序以及程序输出消息的适合，都是通过操作系统OS进行的
        即：任何应用程序对硬件的访问，都必须通过操作系统来实现。

        ### Shell 与操作系统的关系与工作原理

            ## 📌 什么是 Shell？

                - **Shell 是一个命令行界面程序（Command-Line Interface, CLI）**。
                - 它负责作为 **用户与操作系统内核之间的桥梁**。
                - Shell 本身是一个运行在用户空间的普通程序（如 Bash、Zsh、Fish 等）。

                ---

            ## 🧠 Shell 的核心职责

                | 步骤 | 动作                     | 说明 |
                |------|--------------------------|------|
                | 1    | 等待用户输入命令         | 显示提示符（如 `$`），等待输入 |
                | 2    | 解析命令行               | 拆解为命令 + 参数 + 重定向 + 管道等 |
                | 3    | 查找命令程序路径         | 通常在 `$PATH` 环境变量所列目录中寻找 |
                | 4    | 执行命令程序             | 使用系统调用（如 `execve`）请求操作系统内核加载并执行程序 |
                | 5    | 等待程序运行             | 等待进程结束（前台进程）或立即返回（后台进程） |
                | 6    | 显示程序输出             | 将 stdout、stderr 输出显示在终端上 |
                | 7    | 回到提示符               | Shell 等待下一条命令输入 |

                ---

            ## 🧭 Shell 与操作系统内核的关系

                - Shell **不是操作系统内核**，也不是其功能的一部分。
                - 它是一个 **运行在用户空间的程序**，依赖 **系统调用** 与内核交互。
                - 系统调用（如 `execve`, `fork`, `wait` 等）才是实际请求系统资源的机制。

                ---

            ## 🪟 Shell 与图形界面的区别

                - 在 GUI 系统中（如 Windows/macOS/Linux），用户可以**双击图标**启动程序。
                - 这背后实际上也会调用操作系统执行程序，只是由图形界面封装和触发。
                - 而 Shell 通过 **手动输入命令** 来调用程序，适用于服务器和开发环境中没有 GUI 的情况。

                ---

            ## 🧩 图示流程（简化版）

                ```text
                你 ——→ shell ——→ 操作系统内核 ——→ 程序加载 & 执行
                ↑           ↓
                命令输入    输出显示
                            

        ### 操作系统的两个基本功能与三大抽象

            #### 两个基本功能

                | 编号  | 功能描述                     | 说明                                              |
                | --- | ------------------------ | ----------------------------------------------- |
                | (1) | **防止硬件被失控的应用程序滥用**       | 操作系统通过权限管理、用户态/内核态隔离等机制，防止程序任意访问或破坏硬件资源         |
                | (2) | **向应用程序提供简单一致的机制控制复杂硬件** | 屏蔽底层设备差异，让程序员通过统一接口（如 `read()`、`write()`）使用不同设备 |

            #### 三个基本抽象概念

                | 抽象名称     | 抽象对象的真实硬件             | 功能说明                                  |
                | -------- | --------------------- | ------------------------------------- |
                | **进程**   | CPU + 主存 + I/O 设备     | 程序运行的抽象单元，拥有私有地址空间、寄存器等，代表“一个正在执行的程序” |
                | **虚拟内存** | 主存（RAM）+ 磁盘（硬盘/SSD）   | 将每个进程看到的内存空间虚拟化，程序使用的是地址，实际可能来自磁盘     |
                | **文件**   | 各类 I/O 设备（磁盘、显示器、键盘等） | 把所有 I/O 操作抽象为文件操作，实现统一的访问方式（“一切皆文件”）  |

            #### 图1-11

                +-----------+  ← 抽象：进程
                |   进程    |  ← 抽象：程序运行实体
                +-----------+               
                    ↓
                +-----------+  ← 抽象：虚拟内存
                | 虚拟内存   |  ← 实际可能来自主存或磁盘
                +-----------+
                    ↓
                +-----------+  ← 抽象：文件
                |   文件    |  ← 磁盘、键盘、显示器的统一抽象表示
                +-----------+

        ### Unix、Posix 和标准 Unix 规范

            #### 🏛️ Unix 的起源

                - 20 世纪 60 年代：大型复杂操作系统盛行，如 IBM 的 **OS/360** 和 Honeywell 的 **Multics**。
                - Multics 项目因复杂而进展缓慢，1969 年贝尔实验室退出项目。
                - Ken Thompson、Dennis Ritchie、Doug McIlroy 和 Joe Ossanna 用 C 写了一个简洁的操作系统，运行在 DEC PDP-7 上。
                - 借鉴了 Multics 的思想，设计了分层结构和 shell 概念。
                - 1970 年，Brian Kernighan 命名该系统为 **Unix**（取自 “Multics” 的戏仿）。
                - 1973 年 Unix 用 C 语言重写，1974 年对外发布。

            #### 🧬 Unix 的传播与分支

                - Unix 代码被授权给高校，便于研究和扩展，推动了其广泛传播。
                - 重要分支：
                - **System V（商用）**：由 AT&T 推出，代表如 Sun 的 Solaris。
                - **BSD（学术）**：由加州大学伯克利分校推出，代表如 FreeBSD、NetBSD。
                - **xBSD**：BSD 的系列版本，也称为 Unix 4。

                | 类型   | 代表系统               | 特点         |
                |--------|------------------------|--------------|
                | 商业版 | System V, Solaris 等   | 企业支持、稳定 |
                | 学术版 | BSD, FreeBSD, NetBSD   | 开源自由、社区活跃 |
                | 统一化 | POSIX                  | 标准化接口   |

            #### 📐 Posix 标准与统一化努力

                - 80 年代：Unix 分裂导致兼容性差、移植困难。
                - IEEE 与 ISO 推动统一接口标准，形成 **POSIX**（Portable Operating System Interface）。
                - POSIX 标准涵盖：
                - C 编程接口（API）
                - shell 命令行为
                - 线程与网络接口

            #### 📘 标准 Unix 规范

                - 后来发展出“**标准化 Unix 规范**”（Single Unix Specification），由多个组织共同维护，统一 Unix 系统行为。
                - 这些标准构成了现代 Unix-like 系统（如 Linux、macOS 等）的基础。

                ---

                > Unix 是从复杂中脱胎而出的简洁哲学的代表，通过 POSIX 标准实现了统一，使得跨平台开发成为可能。
            
        ### 1.7.1 进程

            #### 并发与并行

                | 概念     | 并发（Concurrency）                           | 并行（Parallelism）                         |
                |--------|--------------------------------------------|------------------------------------------|
                | 定义     | 多个进程轮流执行，同一时刻只有一个进程在运行              | 多个进程真正同时运行                           |
                | 场景     | 单核 CPU                                  | 多核 CPU                                 |
                | 执行方式  | 操作系统通过 **上下文切换** 来切换进程              | 每个进程分配不同的 CPU 核心并同时运行             |
                | 效果     | 表面上“同时运行”，实际是交替进行                   | 实际上就是“同时运行”                         |
                | 类比     | 一个服务员轮流为多个顾客服务                        | 多个服务员同时为多个顾客服务                    |
                | 举例     | 单核 CPU 执行 100 个进程，每次一个                     | 4 核 CPU 执行 100 个进程，每次可同时运行 4 个进程     |

            #### 🌀 上下文切换（Context Switch）

                上下文切换是指操作系统暂停当前进程的执行，保存其状态（上下文），然后恢复另一个进程的状态并开始执行该进程的过程。

                ##### ✅ 上下文包含的信息
                    - 程序计数器（PC）：下一条要执行的指令地址
                    - 寄存器内容：通用寄存器、栈指针、基址寄存器等
                    - 内存映射信息（页表等）
                    - 进程控制块（PCB）中的调度信息

                ##### 📌 发生时机
                    - 进程主动让出 CPU（如：I/O 阻塞、sleep）
                    - 时间片耗尽，被抢占式调度
                    - 系统调用（如：`read()`）进入内核态后发生切换
                    - 硬件中断（如磁盘 I/O 完成）

                ##### 🪛 实现过程
                    1. 当前进程进入内核态
                    2. 保存当前进程上下文
                    3. 选择下一个就绪进程
                    4. 恢复新进程上下文
                    5. 返回用户态继续运行

                ##### 🚩 特点
                    - 是一种内核级操作
                    - 代价较高（CPU 开销 + 缓存污染）
                    - 多任务操作系统的核心机制
            
            #### 🧠 操作系统内核（Kernel）

                内核是操作系统中负责 **管理硬件资源** 和 **协调用户程序执行** 的核心部分，常驻内存。

                ##### 📌 核心职责
                    - 进程调度：决定哪个进程何时运行
                    - 内存管理：分配/释放主存、虚拟内存支持
                    - 文件系统：提供文件访问、权限控制
                    - 系统调用接口：为用户程序提供安全访问硬件的方式
                    - 中断处理：响应硬件事件（I/O、时钟等）

                ##### 🧭 工作方式
                    - 用户进程通过**系统调用（system call）**进入内核态
                    - 内核接管控制权、执行服务逻辑
                    - 操作完成后，再返回用户态

                ##### ❗ 注意事项
                    - **内核不是进程**：它不是单独运行的程序
                    - 是一段长期驻留内存的共享代码（被多个进程调用）
                    - 所有的系统资源都受内核统一调度和保护

                ##### 🧩 示例系统调用
                    | 操作             | 对应系统调用         |
                    |------------------|----------------------|
                    | 运行新程序       | `execve()`           |
                    | 打开文件         | `open()`             |
                    | 读写磁盘         | `read()`, `write()` |
                    | 创建进程         | `fork()`             |

        ### 1.7.2 线程

            | 对比维度    | **进程（Process）**                 | **线程（Thread）**                      |
            | ------- | ------------------------------- | ----------------------------------- |
            | 基本定义    | 操作系统中资源分配的基本单位，拥有完整的内存空间和上下文    | 进程中的执行单元，共享进程的内存资源，但拥有自己的执行状态       |
            | 是否独立    | 是独立的程序执行实例                      | 是依附于进程的，不能独立存在                      |
            | 内存空间    | 每个进程有自己独立的内存空间（代码段、数据段、堆栈）      | 多个线程共享所属进程的内存空间（共享代码段、全局变量），栈空间各自独立 |
            | 数据共享    | 多进程之间默认不共享数据（需通过 IPC 实现，如管道、信号） | 多线程天然共享数据（同一地址空间）                   |
            | 创建和销毁代价 | 开销较大（需要分配独立资源、上下文）              | 开销较小（只需新建线程控制块，资源复用）                |
            | 切换效率    | 切换成本较高（完整上下文切换）                 | 切换更快（只切换线程的部分状态，如寄存器和栈）             |
            | 稳定性     | 一个进程崩溃通常不会影响其他进程                | 一个线程崩溃可能导致整个进程崩溃（因为共享地址空间）          |
            | 使用场景    | 稳定性优先、资源隔离要求高的服务（如浏览器主进程、数据库）   | 轻量级并发场景，如 Web 服务器处理请求、GUI 响应用户点击    |

        ### 1.7.3 虚拟内存

            #### 图1-14 🧠 虚拟地址空间结构（从低地址到高地址）

                | 区域                  | 描述说明 |
                |-----------------------|----------|
                | **只读的代码和数据**       | 程序的指令（代码段）和只读全局变量，**从 hello 可执行文件加载而来**。 |
                | **读/写数据段**          | 存放可修改的全局变量、静态变量等。 |
                | **堆（Heap）**         | 程序运行时动态分配的内存区域，由 `malloc/free` 操作，**可向上增长**。 |
                | **共享库映射区**        | 包括标准 C 库、数学库等共享库，**所有进程共享这段代码**（例如 `printf` 函数）。 |
                | **栈（Stack）**        | 用于函数调用和局部变量，**由编译器管理、运行时自动分配，向下增长**。 |
                | **内核虚拟内存区域**     | 操作系统核心代码与数据，**用户程序不可访问**。必须通过系统调用与之交互。 |
        
            #### 程序代码和数据（Code + Data）

                - 每个进程都拥有自己的虚拟地址空间，看到的内存地址是从 **固定地址开始** 的。
                - 虚拟地址空间底部通常包含两部分：
                1. **代码区**（只读）：从可执行文件中加载的机器指令（如 main 函数的内容）。
                2. **数据区**（可读写）：用于存放已初始化的#全局变量和静态变量。

                    | 类型             | 定义位置       | 生命周期           | 作用域             | 是否可多次初始化 | 使用场景说明                                      |
                    |------------------|----------------|--------------------|---------------------|------------------|---------------------------------------------------|
                    | 全局变量          | 所有函数外部   | 程序整个运行期间     | 所有函数内部可访问     | 否               | 程序中共享的数据，多个函数都需要访问的变量。               |
                    | 局部变量          | 函数或语句块内部 | 每次进入函数时创建，离开时销毁 | 仅在所在函数或块内可见 | 是               | 函数内部使用的临时变量，每次调用都从头开始。             |
                    | 静态变量（统称）   | 用 `static` 修饰 | 程序整个运行期间     | 取决于定义位置         | 否               | 保留值的同时限制作用域。                                |
                    | 全局静态变量      | 函数外部用 `static` 修饰 | 程序整个运行期间 | 只在当前源文件中可访问   | 否               | 全局变量但不暴露给其他文件，用于模块内部封装。             |
                    | 局部静态变量      | 函数内部用 `static` 修饰 | 程序整个运行期间 | 仅在所在函数中可访问     | 否               | 函数调用时保持上一次调用的值，常用于计数、记忆上次状态等。   |

                    ---

                    ## 🧠 简要说明

                        - `生命周期` 表示变量在程序运行过程中存在的时间段。
                        - `作用域` 表示哪些代码可以访问这个变量。
                        - `static` 的主要作用是**延长变量的生命周期**（变为整个程序运行期间存在）并**限制作用域**（防止外部访问）。

                        ---

                    ## 🧪 举例说明（变量的可见性和持续性）

                        - **全局变量**：所有函数都能访问，程序结束才释放。
                        - **局部变量**：函数内定义，每次调用时新建，用完即丢。
                        - **局部静态变量**：只在函数内能访问，但值不会丢失，下次还能接着用。
                        - **全局静态变量**：外部文件看不到这个变量，起到“私有化”的作用。

                        ---

                - 这两个区域的内容都来自于可执行目标文件（如 `hello` 程序）。
                - 代码通常设置为只读保护，防止被意外修改；
                数据段是可读写的，因为变量的值在程序运行中可能变化。

            #### 堆（Heap）

                堆是一种用于 **动态内存分配** 的内存区域，和栈（stack）相对。

                ### 📌 基本特性

                    | 特性           | 内容说明                                                                 |
                    |----------------|--------------------------------------------------------------------------|
                    | 所属区域       | 虚拟地址空间的一部分，在代码和全局数据区之后                           |
                    | 生命周期       | 程序运行时动态创建，使用 `malloc` 分配，使用 `free` 释放                  |
                    | 管理方式       | 程序员显式管理，需要手动分配与释放                                       |
                    | 作用范围       | 程序中的任意函数都可以访问 heap 上的数据                                 |
                    | 访问方式       | 通过指针（如 `int *ptr`）进行间接访问                                    |

                ### 🛠 常用函数（C语言）

                    | 函数      | 说明                                     |
                    |-----------|------------------------------------------|
                    | `malloc`  | 动态分配指定字节的内存，返回 `void*` 指针 |
                    | `free`    | 释放之前 `malloc` 分配的内存              |

                ### ✅ 示例操作流程（简化版）

                    ```c
                    int *ptr = malloc(5 * sizeof(int));  // 分配存放5个int的空间
                    if (ptr == NULL) {
                        // 处理分配失败情况
                    }
                    for (int i = 0; i < 5; i++) {
                        ptr[i] = i * 10;  // 向堆中写入数据
                    }
                    free(ptr);  // 释放分配的堆内存

            #### 共享库


                共享库，又称为 **动态链接库**（Dynamic Linking Library），在 Linux 中通常以 `.so` 结尾（即 Shared Object）。它是被多个程序共享使用的一组代码和数据，**在程序运行时动态加载**。

                ---

                ### 📌 定义与位置

                    - **位置**：共享库通常被加载在**虚拟地址空间的中间部分**，介于堆（Heap）和栈（Stack）之间。
                    - **作用**：用于存放如 C 标准库（如 `libc.so`）或数学库（如 `libm.so`）的函数和数据。

                    ---

                ### ✅ 与静态库的区别

                    | 类型       | 加载时间      | 使用方式                | 特点                     |
                    |------------|---------------|-------------------------|--------------------------|
                    | 静态库     | 编译时        | `.a` 文件打包进程序中    | 程序体积大，不共享        |
                    | 共享库     | 运行时        | `.so` 文件动态加载       | 占用空间小，支持共享更新 |

                    ---

                ### ✅ 使用示例

                    ```c
                    // 使用了共享库中的函数
                    #include <stdio.h>

                    int main() {
                        printf("Hello, world!\n");
                        return 0;
                    }
            

            #### 📚 栈（Stack）与函数调用过程详解

                #### 栈的基本概念

                    栈（Stack）是内存中用于**函数调用管理**的一块区域，特点是“后进先出”（LIFO）。

                    ### ✅ 栈的用途
                    - 保存函数的**返回地址**
                    - 存放函数的**参数**
                    - 存放函数的**局部变量**
                    - 保存部分**寄存器状态**

                ##### ✅ 栈的结构（从高地址向低地址增长）

                    ```text
                    高地址
                    ↓
                    | 参数      |
                    | 返回地址  |
                    | 前一个帧指针 |
                    | 局部变量  |
                    ↑
                    低地址

                ##### 使用 GDB 调试函数调用过程（完整 CLI 实践记录）

                    本记录总结了使用 GDB（GNU 调试器）在 Linux CLI 中调试 C 程序函数调用栈的全过程。

                    ###### 📁 项目准备

                        创建目录并进入：

                        ```bash
                        mkdir ~/for-learn/stack
                        cd ~/for-learn/stack

                    ###### 创建 C 源码 call_stack.c
                        
                        include <stdio.h>

                        void func1() {
                            printf("In func1\n");
                        }

                        void func2() {
                            func1();
                            printf("In func2\n");
                        }

                        int main() {
                            printf("In main\n");
                            func2();
                            return 0;
                        }

                    ###### 编译为带调试符号的可执行文件
                        gcc -g call_stack.c -o call_stack
                    ###### 调试开始：启动 GDB
                        gdb ./call_stack
                    ######  开启日志记录
                        set logging file call_stack_log.txt   # 设置日志文件名
                        set logging on                        # 开启日志记录
                        如果提示 deprecated，可以使用：
                        set logging enabled on
                    ######  设置断点并运行
                        break main       # 在 main 函数设置断点
                        run              # 启动程序运行，停在断点处
                    ######  单步执行与查看调用栈
                        step             # 单步进入 printf 或调用的函数
                        bt               # 查看调用栈（backtrace）
                        info locals      # 查看当前函数局部变量
                        你将看到类似如下输出：
                        #0  __GI__IO_puts (str=0x555555556030 "In main") at ./libio/ioputs.c:35
                        #1  main () at call_stack.c:15
                    ###### 停止记录并退出
                        set logging off  # 关闭日志
                        quit             # 退出 GDB
                        输入 y 确认退出：
                        A debugging session is active.

                        Inferior 1 [process 8298] will be killed.

                        Quit anyway? (y or n) y

                    ###### 查看生成的日志
                        cat call_stack_log.txt
                    ###### 知识要点总结
                        | 操作                | 功能说明          |
                        | ----------------- | ------------- |
                        | `gdb ./program`   | 启动 GDB 调试器    |
                        | `set logging ...` | 保存调试输出到文件     |
                        | `break main`      | 设置断点          |
                        | `run`             | 启动程序直到断点处     |
                        | `step` / `next`   | 单步执行进入 / 跳过函数 |
                        | `bt`              | 显示函数调用栈       |
                        | `info locals`     | 显示局部变量        |
                        | `quit`            | 退出调试器         |

            #### 🧠 内核虚拟内存（Kernel Virtual Memory）

                内核虚拟内存是虚拟地址空间中专门保留给操作系统（内核）使用的内存区域，具有以下关键特性：

                ##### 📌 基本定义
                    - 是**虚拟地址空间顶部的一部分**。
                    - 该区域的地址对于用户程序是**不可见、不可读写、不可执行**的。
                    - 只有**操作系统的内核代码**才能访问。

                ##### 🧱 功能与作用
                    - 存放操作系统的：
                    - 内核代码（kernel text）
                    - 内核数据结构（进程表、页表等）
                    - 内核栈（kernel stack）
                    - 中断处理程序
                    - 驱动程序等
                    - 实现用户态与内核态的隔离，**防止用户程序影响系统稳定性与安全性**。

                ##### 🔒 安全机制
                    - 应用程序无法直接访问或操作该区域。
                    - 若非法访问，会触发**段错误（segmentation fault）**。
                    - 用户程序只能通过**系统调用（system call）**间接请求内核执行相关操作。

                ##### 🧩 举例说明
                    | 行为                        | 属于内核虚拟内存吗 | 是否允许用户程序访问 |
                    |-----------------------------|---------------------|------------------------|
                    | 调用 `write()` 写入文件     | ✅ 是（通过系统调用） | ❌ 不能直接访问       |
                    | 访问进程页表或内核栈内容     | ✅ 是                | ❌ 不能直接访问       |
                    | 加载共享库 `libc.so`        | ❌ 用户空间          | ✅ 允许               |
                    | 执行 printf() 输出          | ❌ 用户空间调用       | ✅ 允许               |

                ##### 用户虚拟内存 vs 内核虚拟内存

                    | 特性/作用项     | 用户虚拟内存（蓝色区域）              | 内核虚拟内存（顶部区域）                   |
                    | ---------- | ------------------------- | ------------------------------ |
                    | **访问者**    | 用户进程可以访问                  | 只能由操作系统内核访问                    |
                    | **权限级别**   | 用户态（User Mode）            | 内核态（Kernel Mode）               |
                    | **示例内容**   | 用户栈、堆、共享库、全局变量等           | 内核代码、内核数据结构、中断处理等              |
                    | **是否共享**   | 每个进程独立拥有                  | 所有进程共享同一个内核虚拟空间                |
                    | **是否可见**   | 程序员通过代码直接访问，如 `int x = 1` | 用户代码不可直接看到（只可系统调用访问）           |
                    | **访问方式**   | 普通读写、调用函数即可访问             | 必须通过 `system call` 由内核执行       |
                    | **访问违规后果** | 合法范围内安全访问                 | 非法访问将导致段错误（Segmentation Fault） |
                    | **保护机制**   | 使用用户权限页表映射                | 页表标记为“仅内核可访问”，无法越权访问           |

                ##### 🧠 总结
                    可以将内核虚拟内存理解为：
                    > “**一块虚拟内存中完全由操作系统掌控、应用程序只能通过系统调用与之交互的安全区域**。”

                    这块区域对于系统的安全性、稳定性和多进程环境的可靠调度来说至关重要。
            #### 🗂️ Linux 进程虚拟地址空间结构（图 1-13 总结）

                虚拟地址空间是进程运行时看到的“内存视图”，从底部地址 `0x00000000` 向上递增：

                | 区域名称             | 描述 |
                |----------------------|------|
                | **0x00000000 程序开始** | 虚拟地址从这里开始分配。 |
                | 🟦 **只读的代码和数据** | 由 `hello` 可执行文件加载的机器指令与只读常量，如函数体、`const` 常量等。<br>不可修改，防止程序意外覆盖代码。 |
                | 🟦 **读/写数据段** | 存储初始化的全局变量和静态变量，可以读写。 |
                | 🟦 **运行时堆（heap）** | 通过 `malloc()` 动态申请、`free()` 释放。<br>堆向上增长。 |
                | 🟦 **共享库映射区域** | 存放共享库（如 `printf()` 属于 libc 库）加载到内存后的代码与数据。<br>多个进程可共享。 |
                | 🟦 **用户栈（stack）** | 编译器为函数调用自动生成的局部变量、返回地址等存储空间。<br>栈向下增长。 |
                | 🔒 **内核虚拟内存（Kernel Space）** | 顶部地址区域，保留给操作系统内核使用。<br>用户态程序不可见、不可访问，访问会段错误（segfault）。 |

                > 📌 蓝色区域表示的是 **用户程序可访问的有效虚拟内存空间**，而顶部的“内核虚拟内存”对用户程序**不可见**。

                ##### 🧠 附加说明
                    - 虚拟地址空间是**每个进程私有的**。
                    - 物理内存通过操作系统的地址映射机制（如页表）与虚拟地址对应。
                    - 内核区域的存在是现代操作系统**内核态与用户态隔离机制**的重要体现。

        ### 1.7.4 文件

            - **文件是字节序列**：在 Unix 中，文件本质上只是一些按顺序排列的字节。
            - **所有 I/O 设备都是文件**：磁盘、键盘、屏幕、网络连接都可以看作“文件”。
            - **通过 Unix I/O 系统调用访问**：
            - 常见函数包括 `open()`、`read()`、`write()`、`close()`。
            - **统一的抽象接口**：
            - 屏蔽硬件差异，提升程序的可移植性。
            - 程序员无须关心硬件，只需操作“文件”。
            - **可移植性好**：同一个程序可在不同硬件/系统上无缝运行。

            📌 第 10 章将进一步学习这些 Unix I/O 系统调用的详细内容。

        ### 旁注：Linux 项目的起源

            ### 📜 背景
                - **时间**：1991 年 8 月 25 日  
                - **人物**：Linus Benedict Torvalds，芬兰的研究生  
                - **事件**：Torvalds 在新闻组 `comp.os.minix` 发帖，宣布正在开发一个免费的类 Unix 操作系统内核。

            ### 📢 原始帖子部分内容摘要

                > 我正在做一个（免费的）用在 386（486）AT 上的操作系统（只是业余爱好，它不会像 GNU 那样庞大和专业）。……  
                > 我已经移植了 bash（1.08）和 gcc（1.40），并且看上去能运行。……  
                > 欢迎任何建议，但是我无法保证我能实现它们。:-)

                — Linus (torvalds@kruna.helsinki.fi)

            ### 🌱 启动平台
                - Torvalds 的 Linux 起点是 **Minix**，这是由 Andrew S. Tanenbaum 为教学目的而开发的操作系统。

            ### 🌍 发展成就
                - Linux 从一个个人项目逐渐演变成全球范围的技术与文化现象。
                - 与 **GNU 项目**结合，Linux 成为了完整的符合 POSIX 标准的 Unix 操作系统。
                - 应用范围：
                - 从手持设备到超级计算机
                - IBM 甚至将 Linux 移植到腕表中！

                ---

            ### 🔎 小结
               Linux 的诞生始于一个学生的兴趣项目，而它之所以能快速成长为全球广泛应用的操作系统，得益于开源文化、GNU 项目的支持以及全球社区的贡献。
    
    ## 1.8 系统之间利用网络通信

        本节核心：**现代计算机系统并不是孤立存在的，而是通过网络与其他系统通信**。网络通信的本质，是将一台主机的数据复制到另一台主机。

        ---

        ### 🧠 1. 网络 = 一种 I/O 设备

            - 网络适配器就像磁盘控制器，是一种**I/O 设备**。
            - 系统将主存中的数据复制到网络适配器 → 数据通过网络 → 到达远程机器。
            - 同理，系统也可以从网络接收数据 → 复制到主存。

            📌 图 1-14：展示网络适配器和其他 I/O 设备（磁盘、图形卡等）并列，都是通过 I/O 总线连接。

            ---

        ### 🌍 2. 网络通信的重要性

            - 互联网的兴起使得**跨主机通信**成为计算机最重要的用途之一。
            - 常见网络应用：
            - 电子邮件
            - 即时通信（IM）
            - 万维网（WWW）
            - FTP（文件传输）
            - Telnet（远程终端登录）

            ---

        ### 🔁 3.图 1-15 Telnet 示例：远程执行 hello 程序

            | 步骤      | 描述             | 关键机制      |
            | ------- | -------------- | --------- |
            | ① 输入命令  | 在本地键盘输入        | I/O 输入    |
            | ② 客户端发送 | 数据通过网络传出       | 网络适配器     |
            | ③ 服务端接收 | 数据被远程 shell 处理 | 远程标准输入    |
            | ④ 程序执行  | `hello` 输出结果   | 远程执行，标准输出 |
            | ⑤ 输出返回  | 结果回传显示         | 网络回传，终端输出 |

        ### 🧱 4. 通信模式的普遍性

        - telnet 的 **客户端-服务器交互模式** 是网络应用程序的通用结构。
        - 所有典型的网络应用（Web、邮件、远程桌面、API 通信等）都遵循类似流程：

        ### 相关概念补充

            | 名称         | 内容说明 |
            |--------------|----------|
            | 网络适配器   | 通过 I/O 总线与主存通信，实现数据发送与接收 |
            | Telnet       | 早期远程登录协议，默认端口 **23 (TCP)** |
            | 客户端/服务器 | 通信的两端，一方发起请求，一方响应处理 |
            | 网络通信本质 | 本质是“跨主机的数据复制” |
            | 端口 + 协议  | 通常配合 TCP/UDP 使用，如 HTTP = 80/TCP |
    
    ## 1.9 重要主题
        ### 1.9.1 Amdahl 定律
            #### ✅ 一、Amdahl 定律的背景与核心思想

                > 提出者：Gene Amdahl（计算机体系结构先驱）

            #### 🎯 核心观点：
                系统性能的提升 **不仅取决于加速的倍数**，更取决于你加速的部分 **在系统中占的比例**。

                即：
                > **优化小部分 → 整体影响有限；优化瓶颈 → 效果显著**

                ---

            #### 🧮 二、变量解释（四个关键变量）

                | 符号 | 含义 |
                |------|------|
                | `T_old` | 优化前整个程序的执行时间 |
                | `α` (alpha) | 可优化部分占整个执行时间的比例（0～1） |
                | `k` | 可优化部分加速的倍数 |
                | `S` | 加速比 = 优化前时间 / 优化后时间 |

                ---

            #### 📐 三、公式总结

                T_new = T_old × [(1 - α) + α / k]

        ### 1.9.2 并发和并行

            #### 线程级并发
                ##### 进程与线程

                    | 比较项             | 进程（Process）                         | 线程（Thread）                            |
                    |------------------|--------------------------------------|----------------------------------------|
                    | 定义              | 程序运行的实例，拥有独立资源和内存空间         | 进程中的执行单元，多个线程共享进程资源         |
                    | 是否独立调度与分配资源 | 是                                      | 否（依赖所属进程）                          |
                    | 内存空间           | 拥有独立的地址空间                          | 与所属进程共享地址空间（代码段、数据段等）         |
                    | 创建开销           | 较大（需分配新的资源，如内存页、PCB 等）         | 较小（共用资源）                           |
                    | 通信方式           | 进程间通信（IPC），如管道、共享内存、消息队列等 | 同一进程内共享内存，通信较简单                    |
                    | 出错影响           | 一个进程崩溃不影响其他进程                   | 一个线程崩溃可能影响整个进程中的所有线程             |
                    | 并发能力           | 支持                                     | 更强（适合实现高并发，如多任务处理）                 |
                    | 使用场景           | 独立运行的大型程序（如浏览器、IDE 等）          | 相互配合的任务（如网页加载中的文字、图片等并发处理） |

                ##### 图 1-16：所有的处理器分类

                    ```
                    +------------------+
                    |  所有的处理器     |
                    |  +------------+  |
                    |  | 单处理器   |  |
                    |  +------------+  |
                    |  +-----------------------------+  |
                    |  | 多处理器                    |  |
                    |  |  +---------+  +----------+  |
                    |  |  | 多核    |  | 超线程的 |  |
                    |  |  +---------+  +----------+  |
                    |  +-----------------------------+  |
                    +------------------+
                    ```

                    - 单处理器（Single Processor）：传统架构，只能同时处理一个任务。
                    - 多处理器（Multiprocessor）：包含多个核心或支持多线程。
                        - 多核（Multicore）：多个 CPU 核心被集成在同一个芯片上。
                        - 超线程（Hyper-Threading）：一个核心支持多个线程，提升资源利用率。
                    - 实际系统中可以 **多核 + 超线程并存**（如 Intel 8核16线程）。

                    ---

                ##### 图 1-17：典型多核处理器结构

                                    +------------------------------+
                                    |       处理器封装包           |
                                    |  +--------+     +--------+   |
                                    |  |  核0   | ... |  核3   |   |
                                    |  |        |     |        |   |
                                    |  |  寄存器|     |  寄存器|   |
                                    |  |  L1数据缓存             |   |
                                    |  |  L1指令缓存             |   |
                                    |  |  L2统一缓存             |   |
                                    |  +--------+     +--------+   |
                                    |          |       |           |
                                    |     +-------------------+    |
                                    |     |   L3统一缓存（共享） |    |
                                    |     +-------------------+    |
                                    +-------------|----------------+
                                                |
                                                +------+
                                                | 主存 |
                                                +------+

                    ####### 🧠 结构说明：

                        - 每个核心（Core）：
                        - 有自己独立的 **L1 数据缓存** 与 **L1 指令缓存**
                        - 拥有自己的 **L2 缓存**
                        - 所有核心共享 **L3 缓存**，用于核心间通信与数据同步
                        - 最终通过总线访问 **主存（RAM）**

                    ####### ⚙️ 访问流程（逐级）：

                        ```text
                        L1（最近，最快） → L2 → L3 → 主存（最远，最慢）
                        ```

                        - 数据先尝试在 L1 中查找，找不到则逐层往下；
                        - 跳级访问主存是极少数特例（如 DMA 或特殊指令），默认不会跳过中间层。

                        ---
                ##### 超线程（Simultaneous Multi-Threading, SMT）
                    又称 同时多线程，是一种允许 一个 CPU 核心同时管理多个线程 的技术。

                    原理：

                    某些硬件（如程序计数器、寄存器文件）有多个副本；

                    其他核心资源（如浮点运算单元）则由多个线程共享。

                    优势：

                    普通 CPU 切换线程需约 20000 个时钟周期；

                    超线程可在 一个时钟周期内快速切换执行线程；

                    有效避免 CPU 等待资源（如缓存）时空转，提高利用率。

                    实例：

                    Intel Core i7：每个核心支持 2 个线程；

                    因此，4 核处理器可并行运行 8 个线程。

            #### 指令级并行

                ##### 概述
                                        
                    在较低的抽象层次上，现代处理器能够在**每个时钟周期中执行多条指令**，这种能力称为 **指令级并行（ILP）**。

                #####  🏗️ 一、流水线（Pipelining）

                    流水线技术是将一条指令的执行分成多个阶段，每个阶段由专门的硬件负责。就像工厂的流水线一样，**不同阶段可以同时处理不同指令的不同部分**。

                ##### 📌 示例阶段划分：

                    1. 指令获取（IF）
                    2. 解码（ID）
                    3. 执行（EX）
                    4. 访存（MEM）
                    5. 写回（WB）

                ##### 🧠 类比说明：

                    就像你写信：
                    - 周期1：你拿起笔（指令1）
                    - 周期2：你拿出本子（指令1 解码，指令2 取指）
                    - 周期3：你开始写字（指令1 执行，指令2 解码，指令3 取指）

                    这就实现了多条指令的**并发推进**。

                    ---

                ##### 🚀 二、超标量（Super-scalar）

                   如果一个处理器能在**同一个时钟周期中发射并执行多条指令**，那么它就是**超标量处理器**。这超越了“一个周期一条指令”的流水线理想速率。

                ##### 📌 超标量特点：

                    - 需要多个**执行单元**（如加法器、乘法器等）
                    - 编译器和硬件都需要支持“找出独立指令”来实现并行执行

                ##### 🧠 类比说明：

                    - 流水线是**你一个人**在依次处理信件
                    - 超标量是**你和两个助手**，**同时处理多封信**
                    - 多个信件一起走上流水线 → 同时推进多个任务

                ##### ✅ 超标量与流水线的关系

                    | 机制        | 功能描述                        | 是否共存 | 示例                         |
                    |-------------|----------------------------------|----------|------------------------------|
                    | 流水线       | 一条指令分阶段执行                | ✅        | 各阶段同时处理不同指令         |
                    | 超标量       | 同时发出多条指令进入流水线         | ✅        | 多条指令并行地“上生产线”处理    |

                    现代 CPU 绝大多数都采用“**多发射 + 深流水线**”结构，即**超标量流水线架构**。

            #### 单指令、多数据并行
                SIMD（Single Instruction, Multiple Data） 是一种并行计算技术，它允许 一条指令 同时作用于多个数据项。适用于大量数据重复处理的场景，例如图像、音频、视频的批量计算。

                ⏱️ 优势：在处理大批量相同类型的数据时，极大提升运算效率。

                🧩 本质：利用处理器中特殊的向量硬件，一次完成多个操作。        
        
        ### 1.9.3 计算机系统中抽象的重要性
                        
            #### ✅ 抽象的定义

                **抽象（Abstraction）** 是计算机系统中最重要的概念之一。  
                它的核心思想是：

                > **隐藏复杂实现，暴露简洁接口**，让用户/程序员可以专注于“做什么”，而非“怎么做”。

                ---

            #### 🧱 主要内容结构

                ###### 1️⃣ 函数与 API 是抽象的基本体现
                    - 函数或接口就像黑箱，使用者只看“怎么用”。
                    - 编程语言通过类、函数原型等支持不同级别的抽象。
                    - 示例：C 语言的函数原型、Java 的类声明。

                    ---

                ##### 2️⃣ 指令集架构（ISA）：对 CPU 的抽象
                    - 把复杂的硬件执行流程抽象为“顺序执行”的模型。
                    - 屏蔽了流水线、乱序执行、并行等底层细节。
                    - 同一 ISA 可由不同厂商实现，提升可移植性。

                    ---

                ##### 3️⃣ 操作系统提供的关键抽象

                    | 抽象名称   | 抽象对象   | 隐藏的复杂性                         |
                    |------------|------------|--------------------------------------|
                    | 文件       | I/O 设备   | 各类设备差异、驱动、通信协议等       |
                    | 虚拟内存   | 主存       | 地址冲突、物理内存限制、程序隔离等   |
                    | 进程       | 程序执行   | 多任务调度、上下文切换、资源管理等   |

                    ---

                ##### 4️⃣ 虚拟机：对整台计算机的抽象
                    - 抽象出一台“虚拟计算机”，包括操作系统、内存、磁盘等。
                    - 起源于 IBM（20 世纪 60 年代），现代用于兼容多个操作系统。
                    - 实例：VMware、VirtualBox、WSL 2、Docker（容器）。

                    ---

            #### 🧠 抽象的意义

                | 优点             | 说明                                       |
                |------------------|--------------------------------------------|
                | 降低复杂性       | 屏蔽硬件差异和系统细节                     |
                | 提高可移植性     | 程序在不同平台上可运行                     |
                | 增强模块化       | 各层间解耦，利于开发与维护                 |
                | 支持系统优化扩展 | 接口不变，内部实现可优化                   |

                ---

            #### 📌 图 1-18 回顾：计算机系统中的抽象层次

                从底层到顶层的抽象结构：

                1. **硬件资源**：处理器、主存、I/O 设备
                2. **指令集架构（ISA）**：抽象 CPU 行为
                3. **虚拟内存 / 文件 / 进程**：操作系统的三大抽象
                4. **虚拟机（VM）**：抽象出完整的虚拟计算机

                ---

            #### ✅ 一句话总结

              > 抽象是一种 **化繁为简** 的工具，它让我们能够 **构建、理解、使用和管理复杂的计算机系统**，是计算机科学中最根本的设计思想之一。

    ## 1.10 小结
        ### 存储层次结构
            数据传输慢于计算 → 性能瓶颈；

            存储结构：寄存器 > Cache > DRAM > 磁盘；

            高层存储可作低层缓存；

            理解层次结构可优化程序性能。
        ### 操作系统的三个核心抽象
            | 抽象   | 作用              |
            | ---- | --------------- |
            | 文件   | 统一访问所有 I/O 设备   |
            | 虚拟内存 | 为进程提供私有、连续的地址空间 |
            | 进程   | 程序运行的独立资源单位     |
        ### 网络
            网络让系统间通信成为可能；

            从 OS 角度，网络就是一种特殊的 I/O 设备。

# 第一部分：程序结构和执行
    本部分教你掌握：如何正确地表示数据、理解程序执行的实际过程，并写出快速、安全的代码。
# 第2章：信息的表示和处理
    ## 导言
        ### 为什么学习数值的位级表示？

            计算机以 **二进制**（bit）方式表示所有数据。理解这些表示能帮助我们：

            - 理解数值的精度与范围
            - 掌握运算的本质及其陷阱（如溢出、舍入）
            - 编写更健壮、可移植和安全的程序
            - 掌握底层代码与编译器优化逻辑
            - 提防安全漏洞（黑客常利用数值计算的“异常”行为）

            ---

        ### 数值表示方法对比表

            | 属性               | 无符号编码（Unsigned）                          | 补码编码（Two’s Complement）                                           | 浮点数编码（IEEE 754 Floating-Point）                                   |
            |--------------------|--------------------------------------------------|------------------------------------------------------------------------|--------------------------------------------------------------------------|
            | **用途**           | 表示非负整数                                     | 表示有符号整数（包括正数、负数）                                       | 表示实数（包含小数、科学记数法形式）                                    |
            | **支持负数？**     | ❌ 不支持                                         | ✅ 支持（用补码表示负数）                                               | ✅ 支持（通过符号位）                                                    |
            | **符号位**         | 无                                               | 有（最高位为符号位，0=正，1=负）                                       | 有（1 位，0=正，1=负）                                                  |
            | **整数范围（8位）**| `0 ~ 255`                                        | `-128 ~ +127`                                                          | 非整数系统，用指数表示范围                                               |
            | **表示范围**       | `0 ~ 2^n - 1`                                     | `-2^{n-1} ~ 2^{n-1} - 1`                                                | `±(1 + f) × 2^e`，范围取决于指数位位数                                   |
            | **编码逻辑**       | 普通二进制编码                                   | 正数：与无符号一致；负数：先取反再加 1                                 | \( (-1)^s × 1.M × 2^{E - Bias} \)，标准科学计数法                        |
            | **负数表示方式**   | 无                                               | 补码表示：**按位取反再加 1**                                            | 通过符号位 + 指数偏移                                                    |
            | **加法运算逻辑**   | 正常二进制加法；忽略进位                         | ✅ 可统一使用二进制加法器（正负数通用）                                 | 特殊的浮点加法器：**对齐小数点 → 计算尾数 → 规范化 → 舍入**             |
            | **减法运算逻辑**   | 正常二进制减法                                   | 减法变为“加上负数”（加法电路即可处理）                                 | 同样需对齐小数点，尾数相减后规范化和舍入                                |
            | **乘法运算逻辑**   | 标准乘法逻辑                                     | 补码乘法器（考虑符号位）                                                | 指数相加，尾数相乘，结果再规范化                                        |
            | **是否可能溢出**   | ✅ 可能                                           | ✅ 可能（例如 127 + 1）                                                 | ✅ 有最大/最小指数限制，溢出变为 ±∞，精度不足时可能舍入                 |
            | **是否有舍入误差** | ❌ 无误差（精确）                                 | ❌ 无误差（精确）                                                       | ✅ 有（如 0.1 无法用 float 精确表示）                                   |
            | **是否满足结合律** | ✅ 满足                                           | ✅ 满足                                                                 | ❌ 不满足（浮点加法和乘法都不满足结合律）                               |
            | **表示唯一性**     | ✅ 唯一                                           | ✅ 唯一（无 ±0）                                                        | ❌ 有 ±0、±∞、NaN（非数）等特殊值                                       |
            | **表示精度**       | 由位数决定，固定精度                             | 由位数决定，固定精度                                                   | 指数范围广，尾数长度决定精度；精度有限（如 float 约 7 位十进制有效位） |
            | **主要优势**       | 简单高效，适用于计数器、地址等                   | 可以用统一电路处理正负数，硬件效率高                                   | 表示范围广，可用于非常大或非常小的实数                                  |
            | **主要劣势**       | 无法表示负数                                     | 溢出时可能导致结果“变号”                                               | 有误差、非结合律、实现复杂、调试难                                      |
            | **典型位宽**       | 8/16/32/64 位                                     | 同左                                                                  | float（32位）、double（64位）、quad（128位）                             |
            | **底层标准**       | 通用二进制                                       | 补码标准广泛用于所有主流 CPU 架构                                      | IEEE 754 浮点标准                                                        |

        ### 补码、浮点数 与 十进制的双向转换对照表

            | 转换方向               | 转换规则（通俗版）                                                                 | 注意事项                                                   |
            |------------------------|------------------------------------------------------------------------------------|------------------------------------------------------------|
            | 十进制整数 → 补码      | ✦ 正数：直接转成二进制，前补 0（如 5 → `00000101`）<br>✦ 负数：先取绝对值 → 取反 → 加1 | 固定位宽（如 8/32 位）；超出范围会溢出                    |
            | 补码 → 十进制整数      | ✦ 若首位是 0：直接当无符号二进制解释<br>✦ 若首位是 1：先取反 → 加1 → 加负号         | 记得按正确位数解释；如 8 位补码 `11111111` = -1           |
            | 十进制实数 → 浮点数    | ✦ 转成二进制小数（整数+小数）<br>✦ 归一化为 `1.x × 2^E`<br>✦ 填写符号、指数、尾数字段  | 结果为近似值，不能精确表示如 0.1、π                        |
            | 浮点数 → 十进制实数    | ✦ 提取符号 s、指数 E、尾数 M<br>✦ 还原公式：`(-1)^s × (1+M) × 2^(E-bias)`            | 小数可能无限不循环，实际只能表示为近似值                   |

        ### C/C++ 与 Java 在数字表示上的对比

            - C 和 C++ 使用完全相同的数字编码：补码整数、IEEE 754 浮点
            - Java 设计了更统一的数字标准：
            - 明确规定了每个类型的位数（如 int 是 32 位）
            - 所有平台必须一致（平台无关性更强）

            | 特性        | C / C++                 | Java                       |
            |-------------|--------------------------|----------------------------|
            | int 长度    | 实现相关（如 16/32 位）   | 固定为 32 位                |
            | 整数编码    | 补码为主，但非强制       | 补码（强制）                |
            | 浮点编码    | 通常 IEEE 754，不强制     | IEEE 754（强制）            |
            | 可移植性    | 差异大                   | 表现一致                    |
            | 安全性      | 依赖程序员               | 语言层面更安全              |

            > 本章知识适用于 C 和 C++，也适用于 Java，但要注意细节差异。
    
    
        ### 旁注：怎样阅读本章（第 2 章）

            #### 🧠 本章特点：
                - 重点是数值的 **二进制表示** 和 **运算属性**
                - 涉及一定的数学语言：公式、推导、方程式

            #### 📚 阅读建议：
                1. 原理 + 例子 + 非形式化讲解 的顺序安排
                2. 反复阅读形成直觉，而非一次性记住
                3. 第一次可以跳过推导，之后再回来看
                4. **做练习题非常重要**，能巩固理解并联系实际

            #### ✅ 作者承诺：
                - 数学部分不会超过高中代数
                - 每个抽象概念都会配例子帮你直观理解

        ### 旁注：C 编程语言的演变

            ### 📜 起源
                - C 语言由 Dennis Ritchie 在贝尔实验室开发
                - 与 Unix 系统一起诞生，追求底层控制与可移植性
                - 可以写操作系统、内存管理（如 malloc）

            ### 📚 标准化过程

                | 版本名称   | 年份 | 关键变化                              |
                |------------|------|---------------------------------------|
                | K&R C      | 1978 | 最初版本，无类型安全                  |
                | ANSI C / C89| 1989 | 类型安全函数、标准库函数              |
                | ISO C90    | 1990 | 与 ANSI C 几乎相同                    |
                | C99        | 1999 | 加入 `long long`、布尔、复数           |
                | C11        | 2011 | 线程、原子操作、Unicode 支持          |

            ### 🧰 GCC 编译选项

                - `-std=c89` / `-ansi`：使用 ANSI / ISO C90
                - `-std=c99`：使用 ISO C99
                - `-std=c11`：使用 ISO C11
                - `-std=gnu11`：C11 + GNU 扩展（将成默认）

                ### 📌 本书使用说明

                - 默认采用 **ISO C90**
                - 也包含部分：
                - C99 特性（如布尔类型）
                - C11 特性（如原子操作）
                - C++ 特性（极少）
                - GCC 特性（如内建函数）

                > 📖 学习本书内容时无需担心版本问题，核心语法都源自 ISO C90，现代编译器如 GCC 都能很好支持。

    ## 2.1 信息存储
        ### 虚拟地址和物理地址

            | 项目   | 虚拟地址（Virtual Address） | 物理地址（Physical Address） |
            | ---- | --------------------- | ---------------------- |
            | 面向对象 | 程序员 / 编译器             | 操作系统 / 内存管理单元（MMU）     |
            | 意义   | 程序员眼中的地址              | 实际内存芯片上的地址             |
            | 控制者  | 操作系统分配                | 硬件内存控制器、MMU 管理         |
            | 是否连续 | 通常看起来是连续的             | 实际可能是离散分布的             |
            | 是否固定 | 每次运行程序都可能变            | 固定芯片物理位置               |
            | 映射方式 | 由页表（Page Table）决定     | 页表最终会把虚拟地址翻译成物理地址      |

            虚拟内存中包含的主存和硬盘等都被视作一个整体，
            而其中的每一个字节都有它独一无二的地址，
            这些地址的集合就是一个虚拟地址空间，
            程序员所对应的都是虚拟地址，
            而虚拟的地址想要转化为实际的物理地址
        
        ### 指针存储
           
            - 程序对象包括代码、数据、指针、控制信息等，都存储在虚拟地址空间中
            - C 的指针存储的是对象的虚拟地址
            - 编译器根据指针类型生成访问内存的机器代码
            - 编译完成后，程序本质上只是字节序列，不再包含类型信息

            C 语言的指针 = 存着虚拟地址的变量 + 附带类型信息  
            → 类型决定解引用和偏移方式  
            → 真正的执行是对“字节块”的操作，但类型指导编译器生成什么代码

        ### 2.1.1 十六进制表示法

            #### 十六进制的基本概念

                - **一个字节（8 位）** 的二进制表示范围：`00000000₂` ~ `11111111₂`，即十进制 `0` ~ `255`。
                - **十六进制（Hexadecimal）** 是一种用 16 个符号来表示数值的进位制。
                - 十六进制使用的符号是：
            
            #### 图 2-2 十六进制表示法

                | 十六进制数字 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | A    | B    | C    | D    | E    | F    |
                | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
                | 十进制值   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
                | 二进制值   | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |

            #### 位模式

                | 名词     | 含义                       |
                | ------ | ------------------------ |
                | 位（bit） | 最小的 0 或 1 单位             |
                | 位模式    | 由多个 bit 排成的一个“图案”或“组合”   |
                | 举例     | `10010110`、`00001111` 等等 |

            #### 🔁 二进制 ↔ 十六进制

                二进制转十六进制：
                每 4 位二进制作为一组，从右往左分组，不足 4 位的左边补 0。
                对照转换表即可得到十六进制。

                十六进制转二进制：
                每个十六进制数 → 4 位二进制

            #### 🔁 十进制 ↔ 十六进制

                十进制 → 十六进制：不断 除以 16，取余作为当前位，从下往上写。
                十六进制 → 十进制：将每一位乘以 16 的幂后相加。

            #### 十六进制的位移与补零技巧

                如果某个值是 2ⁿ，可以快速写为十六进制：
                n = i + 4 × j
                n是幂数
                i ∈ [0,3]，  i=0 → 1，i=1 → 2，i=2 → 4，i=3 → 8
                j 是后面跟多少个 0 的位数。

            #### 十六进制加减法运算规则

                十六进制加减法遵循**与十进制类似的运算规则**，但进位和借位的单位是 **16**。

        ### 2.1.2 字数据大小

            #### 1. 什么是“字（word）”和“字长（word size）”
                            
                每台计算机的 CPU 都有一个“字长”，即 CPU 一次能处理的数据位数（如 32 位、64 位）。
                字长决定了虚拟地址的大小范围（即程序最多能访问的内存空间）：
                对于字长为 ω 的机器，虚拟地址范围为 0 ~ 2^ω - 1
                最大虚拟地址空间大小为 2^ω 字节

            #### 2. 虚拟地址空间的发展

                | 字长     | 虚拟地址空间大小                 | 实际意义           |
                | ------ | ------------------------ | -------------- |
                | 32 位系统 | 2³² = 4GB                | 可寻址内存限制        |
                | 64 位系统 | 2⁶⁴ ≈ 18EB（1.84×10¹⁹ 字节） | 理论上几乎无限，可支持大内存 |

            #### 3. 程序是 32 位还是 64 位由编译方式决定

                gcc -m32 prog.c   # 编译成 32 位程序，可运行在 32 和 64 位系统上
                gcc -m64 prog.c   # 编译成 64 位程序，只能在 64 位系统上运行

                程序的“位数”是由编译方式决定的，而不是由操作系统本身决定的。

            #### 4. C 语言中的数据类型大小（见图 2-3）

                | C 声明类型                    | 32 位程序（字节） | 64 位程序（字节） |
                | ------------------------- | ---------- | ---------- |
                | `char`, `unsigned char`   | 1          | 1          |
                | `short`, `unsigned short` | 2          | 2          |
                | `int`, `unsigned`         | 4          | 4          |
                | `long`, `unsigned long`   | 4          | 8          |
                | `int32_t`, `uint32_t`     | 4          | 4          |
                | `int64_t`, `uint64_t`     | 8          | 8          |
                | `char *`                  | 4          | 8          |
                | `float`                   | 4          | 4          |
                | `double`                  | 8          | 8          |

            ####  5. 有符号与无符号类型

                整数类型有两个版本：
                有符号（signed）：可以表示正数、0、负数
                无符号（unsigned）：只表示非负数
                示例等价声明：
                unsigned long
                unsigned long int
                long unsigned
                long unsigned int

            #### 6. char 类型的特殊性

                char 是一种 1 字节的整数类型，通常用于表示字符（如 'A'）。
                然而它本质上就是一个小整数类型，底层存储的是字符的 ASCII 编码值。
                char 的符号性不确定（取决于编译器）：
                有的默认为 signed char
                有的默认为 unsigned char
                ✅ 建议写明：signed char 或 unsigned char，以确保可移植性

            #### 7. 固定大小类型（来自 C99 标准）

                为了避免平台差异带来的数据大小问题，C99 标准引入了如下类型：
                | 类型         | 含义            |
                | ---------- | ------------- |
                | `int32_t`  | 固定为 4 字节有符号整数 |
                | `uint32_t` | 固定为 4 字节无符号整数 |
                | `int64_t`  | 固定为 8 字节有符号整数 |
                | `uint64_t` | 固定为 8 字节无符号整数 |

            #### 8. 指针声明方法

                格式：
                    T *p;
                含义：
                    p 是一个指针变量，指向类型为 T 的对象。
                指针自己也有地址：
                    可以用 &p 得到
                可以有“指向指针的指针”：
                    用 **pp 表示

            #### 9. 可移植性陷阱与建议

                不同系统中：
                指针大小可能是 4 字节或 8 字节
                int 和 long 的大小可能不一致
                过去的程序（32 位系统上编写）常有如下错误：

                用 int 来存放指针：
                    int x = (int)p; // ❌ 在 64 位系统中会丢失一半地址

                ✅ 正确做法：
                使用 intptr_t 来存放指针的整数表示
                不写死类型大小，使用 sizeof() 或固定大小类型

        ### 2.1.3 寻址和字节顺序

            #### 字节顺序的基本概念

                有些数据类型（比如 int、float、double）的大小大于 1 字节，它们在内存中会占据多个连续的字节；   
                为了正确地处理这些对象，计算机系统必须统一两个规则：
                    对象的地址到底指哪一字节？（最小地址）
                    这些字节在内存中按什么顺序排列？（大小端）
                
            #### 最小地址

                当一个对象占据多个字节时，我们通常用**该对象的起始地址**来标识它。
                而这个起始地址，**就是它所占用的内存块中最小的那个字节的地址**。
                假设 x 占据 4 个字节，分布在地址：
                    0x100, 0x101, 0x102, 0x103
                那么：&x == 0x100（即最小地址）
                地址值越小 → 越靠“前面”
                考虑一个 w 位的整数，位序为：
                    x₍w₋₁₎, x₍w₋₂₎, ..., x₁, x₀
                    x₍w₋₁₎：最高有效位（MSB）
                    x₀：最低有效位（LSB）

            #### 两种常见的字节序（Byte Order）

                小端法（Little Endian）
                    最低有效字节（LSB）排在最前（低地址）
                大端法（Big Endian）
                    最高有效字节（MSB）排在最前（低地址）
                以 int x = 0x01234567 为例，按字节拆分：
                    01 23 45 67
                    小端法（Little Endian）：
                        | 地址 | 0x100 | 0x101 | 0x102 | 0x103 |
                        | -- | ----- | ----- | ----- | ----- |
                        | 内容 | 67    | 45    | 23    | 01    |
                    大端法（Big Endian）：
                        | 地址 | 0x100 | 0x101 | 0x102 | 0x103 |
                        | -- | ----- | ----- | ----- | ----- |
                        | 内容 | 01    | 23    | 45    | 67    |

            #### 字节顺序在机器码与反汇编中的体现
                 
                示例指令机器码：
                    地址：0x4004d3  
                    机器码：01 05 43 0b 20 00
                指令结构解析：
                    | 字节序列          | 含义                      |
                    | ------------- | ----------------------- |
                    | `01`          | 操作码（Opcode），表示 `add` 指令 |
                    | `05`          | ModR/M 字节，表示使用 RIP 相对寻址 |
                    | `43 0b 20 00` | 偏移量 0x200b43 的小端法表示     |
                汇编器反汇编结果：
            
                    add %eax, 0x200b43(%rip)
                    把 %eax 中的 32 位整数加到 [rip + 0x200b43] 指向的内存地址中的值上。

            #### 图2-4代码讲解
                # #include <stdio.h>
                    '告诉编译器“我要用标准输入输出功能”'
                    '#' 表示：这一句不是 C 语言本身的语法，而是 预处理指令（preprocessor directive）。
                    include表示“包含进来一个外部的文件”。
                    stdio.h 是一个 头文件（header file），它包含了很多和“输入输出”相关的函数的声明
                # typedef unsigned char *byte_pointer;
                    '给复杂的类型 unsigned char * 起一个新名字，叫做 byte_pointer'
                    typedef是 C 语言中的类型重命名语法；写法是：typedef 旧类型 新名字;
                    unsigned char 就是无符号的单个字节（byte）
                # void show_bytes(byte_pointer start, size_t len)
                    '这是一个 函数定义 的开头，它表示程序中有一个名叫 show_bytes 的函数'
                    void是函数的返回类型，表示：这个函数不返回任何值。也就是说，它只是执行一些动作（比如打印），不需要把结果“交还”给谁。
                    show_bytes是函数的名字，表示：“展示字节”的意思。它的功能就是：从某个内存地址开始，连续读取若干个字节，并且打印出来。
                    byte_pointer'它其实是 unsigned char *' start，第一个参数：一个指向字节（byte）的指针，表示内存的起始地址。它告诉函数：“你从哪个内存位置开始打印”。
                    size_t len，这是第二个参数，类型是 size_t，这是 C 语言中专门表示大小或数量的无符号整数类型；len 就是长度，表示要从 start 开始读取多少个字节。
                    这个函数从 start 地址开始，连续读取 len 个字节，并把它们逐个打印出来。
                    不返回任何值，只是把内容输出到屏幕。
                # size_t i;
                    '声明了一个变量 i，它的类型是 size_t，将在接下来的 for 循环中使用'
                    size_t 是 C 语言标准库里定义的一个类型；它本质上是一个 无符号整数类型（比如 unsigned int）；设计目的是用来表示内存的“大小”、“长度”或“索引”；它的值永远不可能是负数。
                # for (i = 0; i < len; i++)
                    '这行代码的意思是：“从第 0 个字节开始，依次打印 len 个字节，每次移动一个位置，直到打印完所有字节为止”'
                    for 是 C 语言的关键字，用来定义一个“循环”；格式通常是：
                        for (初始化; 条件; 每次循环后的操作) {
                            // 循环体
                        }
                    i = 0；初始化，把计数器 i 设置为 0，表示“我们从第一个字节开始打印”。
                    i < len：这是循环继续的条件：
                        len 是我们要打印的字节总数；
                        当 i < len 成立时，循环就会继续；
                        当 i == len 时，说明打印完了 len 个字节，循环就会结束。
                    i++：这是每次循环结束后自动执行的语句：i++ 相当于 i = i + 1；表示我们继续处理下一个字节。
                # printf("%.2x", start[i]);
                    '这行代码的作用是：把当前字节 start[i] 以 两位十六进制 的格式打印出来'
                    printf(...)
                        printf 是 C 语言的标准输出函数；
                        全名是 “print formatted” 的缩写；
                        它来自于 '#include <stdio.h>'，用于输出各种格式的字符串、数字等；
                        举例：
                            printf("Hello\n");                // 输出字符串
                            printf("%d\n", 123);              // 输出整数
                            printf("%f\n", 3.14);             // 输出浮点数
                            printf("%x\n", 255);              // 输出十六进制（ff）
                    %.2x 格式控制字符串，这一段是打印的“格式模板”，拆开来看：
                        | 格式部分 | 含义                  |
                        | ---- | ------------------- |
                        | `%`  | 格式标识符的开头            |
                        | `.2` | 输出**至少两位**，不够的话前面补零 |  
                            %.2x：显示 1 字节（8 位）的内容 → 常用于打印内存字节。
                            %.4x：显示 2 字节（16 位）的内容 → 常用于 short 或 16 位指令。
                            %.8x：显示 4 字节（32 位）的内容 → 常用于 int。
                            %.16x：显示 8 字节（64 位）的内容 → 常用于指针、long long。
                        | `x`  | 表示按**小写十六进制格式**打印整数 |
                        printf("%.2x", 5);   // 打印 05
                    start[i]
                        start 是一个指向字节的指针（类型是 unsigned char *）；
                        start[i] 就是从这个地址开始的第 i 个字节；
                        它的值是一个 unsigned char 类型，也就是 0~255 之间的整数；
                        每次循环都打印一个字节的值。
                        即：i 定义了访问第几个字节，而 start[i] 就是根据 i 在内存中偏移，找到对应的字节并取出来。
                    这行代码的作用是：“打印从 start[i] 位置上读到的那个字节的内容，以两位小写十六进制数的形式显示出来”。
                # printf("\n");
                    '让每次调用 show_bytes() 的结果打印完后自动换行，让输出整洁、分明'
                    \n 是一个 转义字符，表示 “换行符”；当你在 printf 中写 \n，就相当于告诉程序：在这里插入一个“回车换行”，让输出跳到下一行开始显示。
                    即：所有字节输出完成后换行，让下次打印从新的一行开始
                # void show_int(int x) {
                    '定义了一个函数，名叫 show_int，它接受一个整数参数 x，然后不返回任何结果，而是做一些操作（比如打印它的字节组成）'
                    void是函数的返回类型，表示：这个函数不返回任何值。
                    show_int 展示一个 int 类型变量的字节表示。
                    (int x) 函数有一个参数：x，类型是 int（整型，4 字节）；
                # show_bytes((byte_pointer) &x, sizeof(int));
                    第一步 &x —— 取地址操作符
                        & 是 取地址运算符；
                        &x 表示：获取变量 x 在内存中的起始地址；
                        返回的结果是一个指针，类型是 int *。
                    第二步 (byte_pointer) &x —— 强制类型转换
                        byte_pointer 是前面通过 typedef 定义的新类型，其实等价于 unsigned char *；
                        把 &x（类型是 int *）强制转换为 byte_pointer，
                        本来 &x 是“指向一个整型值”的指针，现在我们强行告诉编译器：把这个地址按字节方式读取
                        转换目的：为了能够逐字节地读取 x 的内存内容。
                    第三步 sizeof(int) —— 获取数据长度
                        sizeof 是 C 语言的运算符，用于获取某种类型或某个变量的“所占字节数”；
                        sizeof(int) 一般返回 4，也就是说 int 占用 4 个字节；
                        这个值作为第二个参数传入 show
                        _bytes()，告诉它打印多少个字节。
                    第四步 调用 show_bytes(...)
                        “把变量 x 的地址强制转换成一个字节指针，从该地址开始，打印连续 4 个字节的内容”。
                        '原本变量的地址指向的是一个整体，比如一个 4 字节的 int，就像一个单词 word。
                        当我们用普通的 int 类型访问它时，程序会把它当作一个整体来看待，相当于直接输出 word 这个词。
                        但如果我们强制把这个地址转换成 unsigned char * 类型（也就是字节指针），那么程序就不再把它当作一个整体，而是一个字节一个字节地看。
                        这样，输出的就是单词里的每个字母——w、o、r、d——相当于把内存中的内容逐字节展现出来，而不是作为一个整体的整数来解释。'
                # void show_float(float x) {show_bytes((byte_pointer) &x, sizeof(float)); }
                    结构跟 show_int 是一模一样的，只是把数据类型从 int 换成了 float
                    把 float 变量所占的那 4 个字节，一个一个打印出来，看到的是它在内存中的真实二进制（十六进制）样子。
                # void show_pointer(void *x) {show_bytes((byte.pointer) &x, sizeof(void *)); }     
                    void 表示这个函数不返回任何值，只执行打印操作。函数内部将指针变量 x 的地址强制转换成 byte_pointer（即 unsigned char *），从而能够逐字节地显示这个指针本身在内存中的实际存储结构。
                    void和printf()的区别 
                        | 项目    | `void`                 | `printf()`             |
                        | ----- | ---------------------- | ---------------------- |
                        | 是什么？  | 一种函数返回值的类型说明           | C 标准库里的输出函数            |
                        | 表示什么？ | 说明“这个函数不返回值”           | 执行格式化输出（比如打印字符串、数字）    |
                        | 举例    | `void show_int(int x)` | `printf("x = %d", x);` |
                        void 是函数类型声明的一部分，表示“我做事但不还东西”；
                        printf() 是做事的工具，负责输出到屏幕。
            
            ####
            ####

