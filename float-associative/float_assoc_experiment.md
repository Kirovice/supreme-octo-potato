# 浮点加法不满足结合律实验

本实验验证了浮点数在加法运算中不满足结合律，说明浮点精度的局限性可能影响实际程序结果。

---

## 🧪 文件结构

```bash
float-associative/
├── float_assoc.c     # 浮点加法结合律验证程序
```

---

## 📄 float_assoc.c

```c
#include <stdio.h>

int main() {
    double a = 3.14;
    double b = 1e20;

    double result1 = (a + b) - b;
    double result2 = a + (b - b);

    printf("(a + b) - b = %.20f\n", result1);
    printf("a + (b - b) = %.20f\n", result2);

    return 0;
}
```

---

## ▶️ 编译运行

```bash
gcc float_assoc.c -o float_assoc
./float_assoc
```

---

## ✅ 实验输出示例

```
(a + b) - b = 0.00000000000000000000
a + (b - b) = 3.14000000000000012434
```

---

## 📌 结果分析

| 表达式               | 实际含义                                       | 结果         |
|----------------------|------------------------------------------------|--------------|
| `(a + b) - b`        | `3.14 + 1e20 ≈ 1e20`，减回 `1e20` 得 0         | `0.0`        |
| `a + (b - b)`        | `b - b = 0.0`，加回 `a`                         | `3.14`       |

- 原因在于：`3.14` 相对于 `1e20` 太小，**被浮点精度“吞掉”了**
- 浮点运算不是数学加法，它的**运算顺序会影响结果**

---

## ✅ 总结

| 项目       | 浮点数运算表现         |
|------------|------------------------|
| 结合律     | ❌ 不满足               |
| 加法顺序   | 会改变最终结果 ⚠️       |
| 原因       | 浮点精度有限，小数可能被忽略 |

---

理解浮点数的运算特性，对编写数值计算程序的可靠性和可移植性至关重要。
